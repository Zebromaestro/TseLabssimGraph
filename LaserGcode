<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced G-Code Generator</title>
    <style>
        /* --- General Body & Layout --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1400px;
            margin: auto;
        }

        .controls {
            flex: 1;
            min-width: 380px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            align-self: flex-start;
        }

        .output {
            flex: 2;
            min-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- Headers and Titles --- */
        h1, h2, h3 {
            border-bottom: 2px solid #e4e6eb;
            padding-bottom: 8px;
            margin-top: 0;
            color: #0d6efd;
        }
        h1 { text-align: center; margin-bottom: 20px; }
        h3 { font-size: 1.1em; border-bottom-width: 1px; margin-top: 20px; }

        /* --- Input Controls --- */
        .param-group, .grid-group, .preview-group {
            margin-bottom: 15px;
        }

        .param-group label, .grid-group label, .preview-group label, .cell-label {
            font-weight: 600;
            margin-bottom: 5px;
            display: block;
        }

        .grid-group, .preset-group { display: flex; gap: 10px; }
        .grid-group > div { flex: 1; }

        input[type="number"], input[type="text"], input[type="file"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
        }

        /* --- Shape Order & Settings List --- */
        #shape-order-list { list-style-type: none; padding: 0; }

        #shape-order-list li {
            padding: 10px; margin-bottom: 8px; background-color: #f8f9fa;
            border: 1px solid #dee2e6; border-radius: 5px; cursor: move;
            display: flex;
            align-items: center; gap: 10px; user-select: none;
        }

        #shape-order-list li.dragging { opacity: 0.5; background: #d0e3ff; }
        #shape-order-list input[type="checkbox"] { width: 18px; height: 18px; }

        /* --- Cell Center Controls --- */
        #cell-centers-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .cell-control-group { background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px; }
        .cell-control-group .coord-group { display: flex; gap: 5px; margin-bottom: 10px; }
        .cell-label { display: flex; justify-content: space-between; align-items: center; }
        .cell-speed-group { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; align-items: center; margin-bottom: 10px; }
        .cell-speed-group label { font-size: 0.9em; font-weight: normal; margin-bottom: 0; }
        .cell-speed-group input { padding: 4px; }
        .radius-display { font-size: 0.9em; color: #6c757d; }

        /* --- Buttons --- */
        .btn {
            width: 100%; padding: 12px; font-size: 16px; font-weight: bold; color: #fff;
            border: none; border-radius: 5px; cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        .btn-group { display: flex; gap: 10px; }

        .copy-btn { background-color: #198754; }
        .copy-btn:hover { background-color: #157347; }
        .download-btn { background-color: #0d6efd; }
        .download-btn:hover { background-color: #0b5ed7; }
        #preset-save-btn { background-color: #0d6efd; }
        #preset-load-btn { background-color: #198754; }
        #preset-delete-btn { background-color: #dc3545; }

        /* --- Output & Canvas --- */
        #preview-canvas {
            width: 100%; height: auto; aspect-ratio: 1 / 1; background: #fff;
            border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .gcode-output-area {
            width: 100%; min-height: 200px; font-family: "Courier New", Courier, monospace;
            font-size: 14px; border: 1px solid #ccc; border-radius: 5px;
            box-sizing: border-box; background: #e9ecef; color: #343a40;
        }

        .output-group {
             background: #fff; padding: 20px; border-radius: 8px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

    </style>
</head>
<body>

    <h1>Advanced G-Code Generator ‚öôÔ∏è</h1>

    <div class="container">
        <div class="controls">
            <h2>Global Settings</h2>
            <div class="param-group">
                <label for="grid-size">Total Bed Size (mm)</label>
                <input type="number" id="grid-size" value="350">
            </div>
            <div class="param-group">
                <label for="travel-speed">Travel Speed (mm/s)</label>
                <input type="number" id="travel-speed" value="100">
            </div>
            <div class="param-group">
                <label for="z-height">Safe Z Height (mm)</label>
                <input type="number" id="z-height" value="20">
            </div>
             <div class="param-group">
                <label for="servo-delay">Servo Delay (ms)</label>
                <input type="number" id="servo-delay" value="1000">
            </div>

            <h3>Preview Settings</h3>
            <div class="preview-group">
                <label class="checkbox-label">
                     <input type="checkbox" id="show-grid" checked>
                     Show 350x350 Grid Overlay
                </label>
            </div>

            <h3>Spiral Parameters</h3>
            <div class="param-group">
                <label for="num-rotations">Spiral Rotations</label>
                <input type="number" id="num-rotations" value="10">
            </div>
            <div class="param-group">
                <label for="spiral-tightness">Spiral Tightness (mm/rad)</label>
                <input type="number" id="spiral-tightness" value="0.8" step="0.1">
            </div>
            <div class="param-group">
                <label for="step-length">Spiral Step Length (mm)</label>
                <input type="number" id="step-length" value="4">
            </div>

            <h3>G-code File Order (Drag to Reorder)</h3>
            <ul id="shape-order-list">
                <li draggable="true" data-shape="square">
                    <input type="checkbox" id="draw-square" checked>
                    <label for="draw-square">üî≤ Squares File</label>
                </li>
                 <li draggable="true" data-shape="circle">
                    <input type="checkbox" id="draw-circle" checked>
                    <label for="draw-circle">‚≠ï Circles File</label>
                </li>
                <li draggable="true" data-shape="spiral">
                    <input type="checkbox" id="draw-spiral" checked>
                    <label for="draw-spiral">üåÄ Spirals File</label>
                </li>
            </ul>

            <h3>Presets</h3>
            <div class="param-group">
                <label for="preset-name">Preset Name</label>
                <input type="text" id="preset-name" placeholder="e.g., High-speed Spirals">
            </div>
            <div class="param-group">
                 <button id="preset-save-btn" class="btn">Save Preset</button>
            </div>
            <div class="param-group">
                <label for="preset-select">Load Preset</label>
                <select id="preset-select"></select>
            </div>
            <div class="btn-group">
                <button id="preset-load-btn" class="btn">Load</button>
                <button id="preset-delete-btn" class="btn">Delete</button>
            </div>


            <h3>Grid Arrangement</h3>
            <div class="grid-group">
                <div>
                    <label for="grid-rows">Rows</label>
                    <input type="number" id="grid-rows" value="1" min="1" max="3">
                </div>
                <div>
                    <label for="grid-cols">Columns</label>
                    <input type="number" id="grid-cols" value="1" min="1" max="3">
                </div>
            </div>

            <h3>Cell Controls (Epicenters, Speeds)</h3>
            <div id="cell-centers-container"></div>

        </div>

        <div class="output">
            <div class="output-group">
                <h2>Preview</h2>
                <canvas id="preview-canvas" width="1000" height="1000"></canvas>
            </div>
            <div id="gcode-outputs-container">
                </div>
        </div>
    </div>

    <script>
        // ===================================================================
        // === EASY-TO-CHANGE PREVIEW SETTINGS ===
        // ===================================================================
        const PREVIEW_IMAGE_OFFSET_X = 190;
        const PREVIEW_IMAGE_OFFSET_Y = -60;
        const PREVIEW_IMAGE_SCALE = 3.1;
        // ===================================================================
        // === LASER SERVO COMMANDS ===
        // ===================================================================
        const LASER_OPEN = 'SET_SERVO SERVO=servo_beam_trap ANGLE=90';
        const LASER_CLOSE = 'SET_SERVO SERVO=servo_beam_trap ANGLE=0';
        // ===================================================================

        // --- GLOBAL STATE & DOM ---
        let backgroundImage = new Image();
        const dom = {
            inputs: {
                gridSize: document.getElementById('grid-size'),
                travelSpeed: document.getElementById('travel-speed'),
                zHeight: document.getElementById('z-height'),
                servoDelay: document.getElementById('servo-delay'),
                numRotations: document.getElementById('num-rotations'),
                spiralTightness: document.getElementById('spiral-tightness'),
                stepLength: document.getElementById('step-length'),
                gridRows: document.getElementById('grid-rows'),
                gridCols: document.getElementById('grid-cols'),
                showGrid: document.getElementById('show-grid'),
            },
            shapeOrderList: document.getElementById('shape-order-list'),
            cellCentersContainer: document.getElementById('cell-centers-container'),
            gcodeOutputsContainer: document.getElementById('gcode-outputs-container'),
            canvas: document.getElementById('preview-canvas'),
            ctx: document.getElementById('preview-canvas').getContext('2d'),
            presets: {
                name: document.getElementById('preset-name'),
                saveBtn: document.getElementById('preset-save-btn'),
                select: document.getElementById('preset-select'),
                loadBtn: document.getElementById('preset-load-btn'),
                deleteBtn: document.getElementById('preset-delete-btn'),
            }
        };

        // --- CORE LOGIC ---
        function collectConfig() {
            const config = {
                shapes: [],
                cellControls: []
            };
            for (const key in dom.inputs) {
                const el = dom.inputs[key];
                config[key] = (el.type === 'checkbox') ? el.checked : parseFloat(el.value);
            }

            const shapeLiElements = dom.shapeOrderList.querySelectorAll('li');
            shapeLiElements.forEach(li => {
                const shapeName = li.getAttribute('data-shape');
                config.shapes.push({
                    name: shapeName,
                    enabled: li.querySelector('input[type="checkbox"]').checked,
                    color: { spiral: '#0d6efd', circle: '#dc3545', square: '#198754' }[shapeName],
                });
            });

            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            cellGroups.forEach(group => {
                config.cellControls.push({
                    x: parseFloat(group.querySelector('.cell-center-x').value),
                    y: parseFloat(group.querySelector('.cell-center-y').value),
                    enabled: group.querySelector('.cell-enabled').checked,
                    speeds: {
                        spiral: parseFloat(group.querySelector('.cell-spiral-speed').value),
                        circle: parseFloat(group.querySelector('.cell-circle-speed').value),
                        square: parseFloat(group.querySelector('.cell-square-speed').value)
                    }
                });
            });
            return config;
        }

        function applyConfig(config) {
            for (const key in dom.inputs) {
                 const el = dom.inputs[key];
                 if (el.type === 'checkbox') {
                     el.checked = config[key];
                 } else if (el) { // Ensure element exists before setting value
                     el.value = config[key];
                 }
            }

            updateCellCenterInputs();

            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            cellGroups.forEach((group, index) => {
                const cellConfig = config.cellControls[index];
                if (cellConfig) {
                    group.querySelector('.cell-center-x').value = cellConfig.x;
                    group.querySelector('.cell-center-y').value = cellConfig.y;
                    group.querySelector('.cell-enabled').checked = cellConfig.enabled;
                    group.querySelector('.cell-spiral-speed').value = cellConfig.speeds.spiral;
                    group.querySelector('.cell-circle-speed').value = cellConfig.speeds.circle;
                    group.querySelector('.cell-square-speed').value = cellConfig.speeds.square;
                }
            });

            const shapeLiElements = dom.shapeOrderList.querySelectorAll('li');
            shapeLiElements.forEach(li => {
                const shapeName = li.getAttribute('data-shape');
                const shapeConfig = config.shapes.find(s => s.name === shapeName);
                if (shapeConfig) {
                    li.querySelector('input[type="checkbox"]').checked = shapeConfig.enabled;
                }
            });

            generate();
        }

        function generate() {
            const config = collectConfig();

            const augmentedData = config.cellControls.map(cell => {
                const center = { x: cell.x, y: cell.y };
                const spiralPoints = generateSpiralPoints(config, center);
                const maxRadius = calculateMaxRadius(spiralPoints, center);
                return {
                    spiralPoints,
                    maxRadius,
                    squareVertices: calculateSquareVertices(maxRadius, center)
                };
            });

            updateRadiusDisplays(augmentedData);

            const gcodeFiles = generateGCodeFiles(config, augmentedData);
            renderGCodeOutputs(gcodeFiles, config);
            drawPreview(config, augmentedData);
        }

        // --- G-CODE GENERATION ---
        function generateGCodeFiles(config, augmentedData) {
            const files = [];
            const f4 = (n) => n.toFixed(4);

            config.shapes.forEach(shapeInfo => {
                if (!shapeInfo.enabled) return;

                let gcode = ``;
                const travelSpeedMin = config.travelSpeed * 60;
                const servoDelay = `G4 P${config.servoDelay} ; Wait before/after servo move\n`;

                gcode += `; G-code for ${shapeInfo.name.toUpperCase()}S\n`;
                gcode += `; Generated using ABSOLUTE positioning (G90)\n`;
                gcode += `; Klipper Arc (I,J) compatible\n`;
                gcode += `; ========================================\n`;
                gcode += `G90\nM140 S0\nM104 S0\nG28\nG0 Z${f4(config.zHeight)} F${travelSpeedMin}\n`;

                config.cellControls.forEach((cell, index) => {
                    if (!cell.enabled) return;

                    const center = { x: cell.x, y: cell.y };
                    const speedMms = cell.speeds[shapeInfo.name];
                    const speedMmm = speedMms * 60;
                    const data = augmentedData[index];

                    gcode += `\n; --- Cell ${index + 1} ${shapeInfo.name} ---\n`;

                    switch (shapeInfo.name) {
                        case 'square': {
                            const v = data.squareVertices;
                            gcode += `G0 X${f4(v.bl.x)} Y${f4(v.bl.y)} F${travelSpeedMin}\n`;
                            gcode += servoDelay;
                            gcode += `${LASER_OPEN}\n`;
                            gcode += servoDelay;
                            gcode += `G1 X${f4(v.br.x)} Y${f4(v.br.y)} F${speedMmm}\n`;
                            gcode += `G1 X${f4(v.tr.x)} Y${f4(v.tr.y)} F${speedMmm}\n`;
                            gcode += `G1 X${f4(v.tl.x)} Y${f4(v.tl.y)} F${speedMmm}\n`;
                            gcode += `G1 X${f4(v.bl.x)} Y${f4(v.bl.y)} F${speedMmm}\n`;
                            gcode += servoDelay;
                            gcode += `${LASER_CLOSE}\n`;
                            gcode += servoDelay;
                            break;
                        }
                        case 'circle': {
                            const maxRadius = data.maxRadius;
                            const startX = center.x + maxRadius;
                            const startY = center.y;
                            gcode += `G0 X${f4(startX)} Y${f4(startY)} F${travelSpeedMin}\n`;
                            gcode += servoDelay;
                            gcode += `${LASER_OPEN}\n`;
                            gcode += servoDelay;
                            gcode += `G2 X${f4(startX)} Y${f4(startY)} I${f4(-maxRadius)} J0 F${speedMmm}\n`;
                            gcode += servoDelay;
                            gcode += `${LASER_CLOSE}\n`;
                            gcode += servoDelay;
                            break;
                        }
                        case 'spiral': {
                            const points = data.spiralPoints;
                            if (points.x.length < 2) break;

                            gcode += `G0 X${f4(points.x[0])} Y${f4(points.y[0])} F${travelSpeedMin}\n`;
                            gcode += servoDelay;
                            gcode += `${LASER_OPEN}\n`;
                            gcode += servoDelay;
                            gcode += `G1 X${f4(points.x[1])} Y${f4(points.y[1])} F${speedMmm}\n`;

                            for (let i = 2; i < points.x.length; i++) {
                                const startPointAbs = { x: points.x[i - 1], y: points.y[i - 1] };
                                const endPointAbs = { x: points.x[i], y: points.y[i] };
                                const arcCenterAbs = { x: center.x, y: center.y };

                                const iOffset = arcCenterAbs.x - startPointAbs.x;
                                const jOffset = arcCenterAbs.y - startPointAbs.y;

                                gcode += `G3 X${f4(endPointAbs.x)} Y${f4(endPointAbs.y)} I${f4(iOffset)} J${f4(jOffset)} F${speedMmm}\n`;
                            }
                            gcode += servoDelay;
                            gcode += `${LASER_CLOSE}\n`;
                            gcode += servoDelay;
                            break;
                        }
                    }
                });

                gcode += `\n; --- End of paths ---\n`;
                gcode += `G90\nG0 Z350 F${travelSpeedMin}\n`;

                files.push({
                    title: `File for ${shapeInfo.name.charAt(0).toUpperCase() + shapeInfo.name.slice(1)}s`,
                    filename: `${shapeInfo.name}s.gcode`,
                    code: gcode
                });
            });

            return files;
        }

        // --- POINT CALCULATION HELPERS ---
        function generateSpiralPoints(p, center) {
            const xPoints = [], yPoints = [];
            const totalAngle = p.numRotations * 2 * Math.PI;
            xPoints.push(center.x); yPoints.push(center.y);

            let theta = 0.001;
            while (theta < totalAngle) {
                const rSpiral = p.spiralTightness * theta;
                const xShifted = (rSpiral * Math.cos(theta)) + center.x;
                const yShifted = (rSpiral * Math.sin(theta)) + center.y;
                xPoints.push(xShifted); yPoints.push(yShifted);
                const dTheta = p.stepLength / (p.spiralTightness * Math.sqrt(1 + theta ** 2));
                theta += dTheta;
            }
            return { x: xPoints, y: yPoints };
        }

        function calculateMaxRadius(spiralPoints, center) {
            if (spiralPoints.x.length < 2) return 0;
            const lastX = spiralPoints.x[spiralPoints.x.length - 1];
            const lastY = spiralPoints.y[spiralPoints.y.length - 1];
            return Math.sqrt((lastX - center.x)**2 + (lastY - center.y)**2);
        }

        function calculateSquareVertices(maxRadius, center) {
            return {
                bl: { x: center.x - maxRadius, y: center.y - maxRadius },
                br: { x: center.x + maxRadius, y: center.y - maxRadius },
                tr: { x: center.x + maxRadius, y: center.y + maxRadius },
                tl: { x: center.x - maxRadius, y: center.y + maxRadius },
            };
        }

        // --- CANVAS PREVIEW ---
        function drawGrid(config) {
            const { ctx, canvas } = dom;
            const scale = canvas.width / config.gridSize;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            const originalFillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillStyle = originalFillStyle;
            ctx.lineWidth = 1;
            ctx.font = '12px sans-serif';

            for (let i = 50; i <= 350; i += 50) {
                const x = i * scale;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(i, x + 5, 5);

                const y = canvas.height - (i * scale);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                ctx.fillText(i, 5, y + 5);
            }

            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.arc(0, canvas.height, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = originalFillStyle;
        }

        function drawPreview(config, augmentedData) {
            const { ctx, canvas } = dom;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth > 0) {
                const canvasRatio = canvas.width / canvas.height;
                const imgRatio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
                let newWidth, newHeight;

                if (imgRatio > canvasRatio) {
                    newWidth = canvas.width;
                    newHeight = canvas.width / imgRatio;
                } else {
                    newHeight = canvas.height;
                    newWidth = canvas.height * imgRatio;
                }

                newWidth *= PREVIEW_IMAGE_SCALE;
                newHeight *= PREVIEW_IMAGE_SCALE;

                const drawX = (canvas.width - newWidth) / 2 + PREVIEW_IMAGE_OFFSET_X;
                const drawY = (canvas.height - newHeight) / 2 + PREVIEW_IMAGE_OFFSET_Y;

                ctx.drawImage(backgroundImage, drawX, drawY, newWidth, newHeight);
            }

            if (config.showGrid) {
                drawGrid(config);
            }

            const scale = canvas.width / config.gridSize;
            const transform = (x, y) => ({ x: x * scale, y: canvas.height - (y * scale) });

            config.cellControls.forEach((cell, index) => {
                if (!cell.enabled) return;

                const data = augmentedData[index];

                config.shapes.forEach(shape => {
                    if (!shape.enabled) return;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = shape.color;
                    ctx.beginPath();

                    switch (shape.name) {
                        case 'spiral':
                            const points = data.spiralPoints;
                            if (points.x.length > 1) {
                                let start = transform(points.x[0], points.y[0]);
                                ctx.moveTo(start.x, start.y);
                                for (let i = 1; i < points.x.length; i++) {
                                    let point = transform(points.x[i], points.y[i]);
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                            break;
                        case 'circle':
                            const canvasCenter = transform(cell.x, cell.y);
                            ctx.arc(canvasCenter.x, canvasCenter.y, data.maxRadius * scale, 0, 2 * Math.PI);
                            break;
                        case 'square':
                            const v = data.squareVertices;
                            let bl = transform(v.bl.x, v.bl.y); let br = transform(v.br.x, v.br.y);
                            let tr = transform(v.tr.x, v.tr.y); let tl = transform(v.tl.x, v.tl.y);
                            ctx.moveTo(bl.x, bl.y); ctx.lineTo(br.x, br.y);
                            ctx.lineTo(tr.x, tr.y); ctx.lineTo(tl.x, tl.y);
                            ctx.closePath();
                            break;
                    }
                    ctx.stroke();
                });
            });
        }

        // --- DYNAMIC UI MANAGEMENT ---
        function renderGCodeOutputs(files) {
            dom.gcodeOutputsContainer.innerHTML = '';
            if (files.length === 0) {
                 dom.gcodeOutputsContainer.innerHTML = '<p>No G-code files to generate. Enable a shape type to begin.</p>';
                 return;
            }
            files.forEach((file) => {
                const outputGroup = document.createElement('div');
                outputGroup.className = 'output-group';

                const title = document.createElement('h2');
                title.textContent = file.title;

                const textarea = document.createElement('textarea');
                textarea.className = 'gcode-output-area';
                textarea.readOnly = true;
                textarea.value = file.code;

                const btnGroup = document.createElement('div');
                btnGroup.className = 'btn-group';

                const copyButton = document.createElement('button');
                copyButton.className = 'btn copy-btn';
                copyButton.textContent = 'üìã Copy';
                copyButton.onclick = () => {
                    textarea.select();
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        copyButton.textContent = '‚úÖ Copied!';
                        setTimeout(() => { copyButton.textContent = 'üìã Copy'; }, 2000);
                    });
                };

                const downloadButton = document.createElement('button');
                downloadButton.className = 'btn download-btn';
                downloadButton.textContent = 'üíæ Download .gcode';
                downloadButton.onclick = () => {
                    const blob = new Blob([file.code], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = file.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                btnGroup.appendChild(copyButton);
                btnGroup.appendChild(downloadButton);
                outputGroup.appendChild(title);
                outputGroup.appendChild(textarea);
                outputGroup.appendChild(btnGroup);
                dom.gcodeOutputsContainer.appendChild(outputGroup);
            });
        }

        function updateRadiusDisplays(augmentedData) {
            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            cellGroups.forEach((group, index) => {
                const radiusDisplay = group.querySelector('.radius-display');
                if (radiusDisplay) {
                    const data = augmentedData[index];
                    radiusDisplay.textContent = `Max Radius: ${data.maxRadius.toFixed(2)} mm`;
                }
            });
        }

        function updateCellCenterInputs() {
            const rows = parseInt(dom.inputs.gridRows.value) || 1;
            const cols = parseInt(dom.inputs.gridCols.value) || 1;
            const gridSize = parseFloat(dom.inputs.gridSize.value);

            dom.cellCentersContainer.innerHTML = '';

            const cellWidth = gridSize / cols;
            const cellHeight = gridSize / rows;

            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    const defaultCenterX = (c - 0.5) * cellWidth;
                    const defaultCenterY = (r - 0.5) * cellHeight;

                    const group = document.createElement('div');
                    group.className = 'cell-control-group';
                    group.innerHTML = `
                        <label class="cell-label">
                            <b>Cell (${r}, ${c})</b>
                            <input type="checkbox" class="cell-enabled" title="Enable/Disable this cell" checked>
                        </label>
                        <div class="coord-group">
                           <input type="number" class="cell-center-x" value="${defaultCenterX.toFixed(2)}" title="Center X (mm)">
                           <input type="number" class="cell-center-y" value="${defaultCenterY.toFixed(2)}" title="Center Y (mm)">
                        </div>
                        <div class="cell-speed-group">
                            <label for="cell-spiral-speed-${r}-${c}">üåÄ Speed (mm/s):</label>
                            <input type="number" class="cell-spiral-speed" id="cell-spiral-speed-${r}-${c}" value="80" title="Spiral Speed (mm/s)">
                            <label for="cell-circle-speed-${r}-${c}">‚≠ï Speed (mm/s):</label>
                            <input type="number" class="cell-circle-speed" id="cell-circle-speed-${r}-${c}" value="100" title="Circle Speed (mm/s)">
                            <label for="cell-square-speed-${r}-${c}">üî≤ Speed (mm/s):</label>
                            <input type="number" class="cell-square-speed" id="cell-square-speed-${r}-${c}" value="70" title="Square Speed (mm/s)">
                        </div>
                        <div class="radius-display">Max Radius: 0.00 mm</div>
                    `;
                    dom.cellCentersContainer.appendChild(group);
                }
            }
            dom.cellCentersContainer.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', generate);
            });
        }

        // --- PRESET MANAGEMENT ---
        const PRESET_STORAGE_KEY = 'gcodeGeneratorPresets';

        function getPresets() {
            return JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
        }

        function savePresets(presets) {
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
        }

        function updatePresetList() {
            const presets = getPresets();
            const select = dom.presets.select;
            select.innerHTML = '';
            for (const name in presets) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            }
        }

        // --- EVENT LISTENERS ---
        Object.values(dom.inputs).forEach(input => {
            if (input) input.addEventListener('input', generate);
        });
        dom.shapeOrderList.querySelectorAll('input').forEach(input => input.addEventListener('input', generate));
        dom.inputs.gridRows.addEventListener('input', () => { updateCellCenterInputs(); generate(); });
        dom.inputs.gridCols.addEventListener('input', () => { updateCellCenterInputs(); generate(); });
        dom.inputs.gridSize.addEventListener('input', () => { updateCellCenterInputs(); generate(); });
        dom.shapeOrderList.addEventListener('drop', generate);

        dom.presets.saveBtn.addEventListener('click', () => {
            const name = dom.presets.name.value.trim();
            if (!name) {
                alert('Please enter a name for the preset.');
                return;
            }
            const presets = getPresets();
            presets[name] = collectConfig();
            savePresets(presets);
            updatePresetList();
            alert(`Preset "${name}" saved!`);
        });

        dom.presets.loadBtn.addEventListener('click', () => {
            const name = dom.presets.select.value;
            if (!name) {
                alert('No preset selected.');
                return;
            }
            const presets = getPresets();
            const config = presets[name];
            if (config) {
                applyConfig(config);
                dom.presets.name.value = name;
                alert(`Preset "${name}" loaded!`);
            }
        });

        dom.presets.deleteBtn.addEventListener('click', () => {
            const name = dom.presets.select.value;
            if (!name) {
                alert('No preset selected.');
                return;
            }
            if (confirm(`Are you sure you want to delete the preset "${name}"?`)) {
                const presets = getPresets();
                delete presets[name];
                savePresets(presets);
                updatePresetList();
                alert(`Preset "${name}" deleted.`);
            }
        });

        dom.shapeOrderList.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(dom.shapeOrderList, e.clientY);
            const dragging = document.querySelector('.dragging');
            if (afterElement == null) dom.shapeOrderList.appendChild(dragging);
            else dom.shapeOrderList.insertBefore(dragging, afterElement);
        });
        dom.shapeOrderList.querySelectorAll('li').forEach(item => {
            item.addEventListener('dragstart', () => setTimeout(() => item.classList.add('dragging'), 0));
            item.addEventListener('dragend', () => item.classList.remove('dragging'));
        });
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            backgroundImage.src = 'REALgridfinitydesign.JPG';
            backgroundImage.onload = () => generate();
            backgroundImage.onerror = () => {
                console.error("Could not load 'REALgridfinitydesign.JPG'. Make sure it is in the same folder as the HTML file.");
                generate();
            };

            updateCellCenterInputs();
            updatePresetList();
            generate();
        });
    </script>
</body>
</html>
