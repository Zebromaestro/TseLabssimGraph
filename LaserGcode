<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced G-Code Generator with Distance Analysis</title>
    <style>
        /* --- General Body & Layout --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1400px;
            margin: auto;
        }

        .controls {
            flex: 1;
            min-width: 380px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            align-self: flex-start;
        }

        .output {
            flex: 2;
            min-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- Headers and Titles --- */
        h1, h2, h3 {
            border-bottom: 2px solid #e4e6eb;
            padding-bottom: 8px;
            margin-top: 0;
            color: #0d6efd;
        }
        h1 { text-align: center; margin-bottom: 20px; }
        h3 { font-size: 1.1em; border-bottom-width: 1px; margin-top: 20px; }
        h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #343a40;
            border-bottom: none;
        }

        /* --- Input Controls --- */
        .param-group, .grid-group, .preview-group {
            margin-bottom: 15px;
        }

        .param-group label, .grid-group label, .preview-group label, .cell-label {
            font-weight: 600;
            margin-bottom: 5px;
            display: block;
        }

        .grid-group, .preset-group { display: flex; gap: 10px; }
        .grid-group > div { flex: 1; }

        input[type="number"], input[type="text"], input[type="file"], select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .param-group textarea {
            font-family: "Courier New", Courier, monospace;
            font-size: 14px;
            resize: vertical;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
        }

        /* --- Shape Order & Settings List --- */
        #shape-order-list { list-style-type: none; padding: 0; }

        #shape-order-list li {
            padding: 10px; margin-bottom: 8px; background-color: #f8f9fa;
            border: 1px solid #dee2e6; border-radius: 5px; cursor: move;
            display: flex;
            align-items: center; gap: 10px; user-select: none;
        }

        #shape-order-list li.dragging { opacity: 0.5; background: #d0e3ff; }
        #shape-order-list input[type="checkbox"] { width: 18px; height: 18px; }

        /* --- Cell Center Controls --- */
        #cell-centers-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .cell-control-group { background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px; }
        .cell-control-group .coord-group { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .cell-control-group .coord-group input { flex: 1; }
        .cell-diameter-label { font-weight: 600; }
        .cell-label { display: flex; justify-content: space-between; align-items: center; }
        .cell-speed-group { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; align-items: center; margin-bottom: 10px; }
        .cell-speed-group label { font-size: 0.9em; font-weight: normal; margin-bottom: 0; }
        .cell-speed-group input { padding: 4px; }
        .diameter-display { font-size: 0.9em; color: #6c757d; font-weight: bold; margin-top: 5px; }

        /* --- Buttons --- */
        .btn {
            width: 100%; padding: 12px; font-size: 16px; font-weight: bold; color: #fff;
            border: none; border-radius: 5px; cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        #apply-btn {
            background-color: #198754;
            margin-bottom: 25px;
        }
        #apply-btn:hover {
            background-color: #157347;
        }
        .btn-group { display: flex; gap: 10px; }

        .copy-btn { background-color: #198754; }
        .copy-btn:hover { background-color: #157347; }
        .download-btn { background-color: #0d6efd; }
        .download-btn:hover { background-color: #0b5ed7; }
        #preset-save-btn { background-color: #0d6efd; }
        #preset-load-btn { background-color: #198754; }
        #preset-delete-btn { background-color: #dc3545; }

        /* --- Output & Canvas --- */
        #preview-canvas {
            width: 100%; height: auto; aspect-ratio: 1 / 1; background: #fff;
            border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .gcode-output-area {
            width: 100%; min-height: 200px; font-family: "Courier New", Courier, monospace;
            font-size: 14px; border: 1px solid #ccc; border-radius: 5px;
            box-sizing: border-box; background: #e9ecef; color: #343a40;
        }

        .output-group {
             background: #fff; padding: 20px; border-radius: 8px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* --- Distance Analysis Table Styles --- */
        #distance-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
            table-layout: fixed;
        }
        #distance-table th, #distance-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            word-wrap: break-word;
        }
        #distance-table th {
            background-color: #e9ecef;
            font-weight: 600;
        }
        #distance-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        #distance-table tfoot td {
            font-weight: bold;
            border-top: 2px solid #0d6efd;
            color: #198754;
        }
       .assumptions {
            font-size: 0.9em;
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            margin-top: 10px;
        }
        .assumptions ul {
            padding-left: 20px;
            margin-bottom: 0;
            margin-top: 5px;
        }

        /* --- Overlap Analysis Styles --- */
        .analysis-calculator {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .result-display {
            margin-top: 10px;
            padding: 12px;
            border-radius: 4px;
            font-size: 1.05em;
            font-weight: 500;
            border-left: 5px solid;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .result-display.safe {
            background-color: #e6f9f0;
            border-color: #198754;
            color: #146c43;
        }
        .result-display.warning {
            background-color: #fff8e6;
            border-color: #ffc107;
            color: #997404;
        }
        .result-display p {
            margin: 0;
            padding: 0;
        }
        .result-display p:first-child {
            margin-bottom: 8px;
        }


    </style>
</head>
<body>

    <h1>Advanced G-Code Generator ‚öôÔ∏è</h1>

    <div class="container">
        <div class="controls">
            <button id="apply-btn" class="btn">üöÄ Apply Changes & Generate</button>

            <h2>Global Settings</h2>
            <div class="param-group">
                <label for="grid-size">Total Bed Size (mm)</label>
                <input type="number" id="grid-size" value="350">
            </div>
             <div class="param-group">
                <label for="num-passes">Number of Passes</label>
                <input type="number" id="num-passes" value="1" min="1">
            </div>
            <div class="param-group">
                <label for="travel-speed">Travel Speed (mm/s)</label>
                <input type="number" id="travel-speed" value="100">
            </div>
            <div class="param-group">
                <label for="z-height">Safe Z Height (mm)</label>
                <input type="number" id="z-height" value="20">
            </div>
             <div class="param-group">
                <label for="servo-delay">Servo Delay (ms)</label>
                <input type="number" id="servo-delay" value="1000">
            </div>

            <h3>Preview Settings</h3>
            <div class="preview-group">
                <label class="checkbox-label">
                     <input type="checkbox" id="show-grid" checked>
                     Show 350x350 Grid Overlay
                </label>
            </div>

            <h3>Spiral Parameters</h3>
            <div class="param-group">
                <label for="num-rotations">Max Spiral Rotations</label>
                <input type="number" id="num-rotations" value="20">
            </div>
            <div class="param-group">
                <label for="spiral-tightness">Spiral Tightness (mm/rad)</label>
                <input type="number" id="spiral-tightness" value="0.8" step="0.1">
            </div>
            <div class="param-group">
                <label for="step-length">Spiral Step Length (mm)</label>
                <input type="number" id="step-length" value="4">
            </div>

            <h3>Custom G-code Scripts</h3>
            <div class="param-group">
                <label for="start-gcode">Start G-code (Placeholders: {Z_HEIGHT}, {TRAVEL_FEEDRATE})</label>
                <textarea id="start-gcode" rows="6"></textarea>
            </div>
            <div class="param-group">
                <label for="end-gcode">End G-code (Placeholder: {TRAVEL_FEEDRATE})</label>
                <textarea id="end-gcode" rows="3"></textarea>
            </div>

            <h3>G-code File Order (Drag to Reorder)</h3>
            <ul id="shape-order-list">
                <li draggable="true" data-shape="square">
                    <input type="checkbox" id="draw-square" checked>
                    <label for="draw-square">üî≤ Squares File</label>
                </li>
                 <li draggable="true" data-shape="circle">
                    <input type="checkbox" id="draw-circle" checked>
                    <label for="draw-circle">‚≠ï Circles File</label>
                </li>
                <li draggable="true" data-shape="spiral">
                    <input type="checkbox" id="draw-spiral" checked>
                    <label for="draw-spiral">üåÄ Spirals File</label>
                </li>
            </ul>

            <h3>Presets</h3>
            <div class="param-group">
                <label for="preset-name">Preset Name</label>
                <input type="text" id="preset-name" placeholder="e.g., High-speed Spirals">
            </div>
            <div class="param-group">
                 <button id="preset-save-btn" class="btn">Save Preset</button>
            </div>
            <div class="param-group">
                <label for="preset-select">Load Preset</label>
                <select id="preset-select"></select>
            </div>
            <div class="btn-group">
                <button id="preset-load-btn" class="btn">Load</button>
                <button id="preset-delete-btn" class="btn">Delete</button>
            </div>


            <h3>Grid Arrangement</h3>
            <div class="grid-group">
                <div>
                    <label for="grid-rows">Rows</label>
                    <input type="number" id="grid-rows" value="1" min="1" max="3">
                </div>
                <div>
                    <label for="grid-cols">Columns</label>
                    <input type="number" id="grid-cols" value="1" min="1" max="3">
                </div>
            </div>

            <h3>Cell Controls (Epicenters, Speeds)</h3>
            <div id="cell-centers-container"></div>

        </div>

        <div class="output">
            <div class="output-group" id="distance-summary-container">
                <h2>Distance & Time Analysis ‚è±Ô∏è</h2>
                <div id="distance-summary">
                    <p>Click "Apply Changes & Generate" to calculate drawing distances and times.</p>
                </div>
            </div>

            <div class="output-group" id="overlap-analysis-container">
                <h2>Spiral Overlap Analysis üî¨</h2>
                <div class="analysis-calculator">
                    <div class="param-group">
                        <label for="laser-width">Laser Beam Width (mm)</label>
                        <input type="number" id="laser-width" value="0.4" step="0.05">
                    </div>
                    <div id="overlap-analysis-result" class="result-display">
                        </div>
                </div>
            </div>

            <div class="output-group">
                <h2>Preview</h2>
                <canvas id="preview-canvas" width="1000" height="1000"></canvas>
            </div>
            <div id="gcode-outputs-container">
                </div>
        </div>
    </div>

    <script>
        // ===================================================================
        // === EASY-TO-CHANGE PREVIEW SETTINGS ===
        // ===================================================================
        const PREVIEW_IMAGE_OFFSET_X = 190;
        const PREVIEW_IMAGE_OFFSET_Y = -60;
        const PREVIEW_IMAGE_SCALE = 3.1;
        // ===================================================================
        // === LASER SERVO COMMANDS ===
        // ===================================================================
        const LASER_OPEN = 'SET_SERVO SERVO=servo_beam_trap ANGLE=90';
        const LASER_CLOSE = 'SET_SERVO SERVO=servo_beam_trap ANGLE=0';
        // ===================================================================

        // --- GLOBAL STATE & DOM ---
        let backgroundImage = new Image();
        const dom = {
            applyBtn: document.getElementById('apply-btn'),
            inputs: {
                gridSize: document.getElementById('grid-size'),
                numPasses: document.getElementById('num-passes'), // New
                travelSpeed: document.getElementById('travel-speed'),
                zHeight: document.getElementById('z-height'),
                servoDelay: document.getElementById('servo-delay'),
                numRotations: document.getElementById('num-rotations'),
                spiralTightness: document.getElementById('spiral-tightness'),
                stepLength: document.getElementById('step-length'),
                startGcode: document.getElementById('start-gcode'),
                endGcode: document.getElementById('end-gcode'),
                gridRows: document.getElementById('grid-rows'),
                gridCols: document.getElementById('grid-cols'),
                showGrid: document.getElementById('show-grid'),
                presetName: document.getElementById('preset-name'),
                laserWidth: document.getElementById('laser-width'),
            },
            shapeOrderList: document.getElementById('shape-order-list'),
            cellCentersContainer: document.getElementById('cell-centers-container'),
            gcodeOutputsContainer: document.getElementById('gcode-outputs-container'),
            distanceSummary: document.getElementById('distance-summary'),
            overlapAnalysisResult: document.getElementById('overlap-analysis-result'),
            canvas: document.getElementById('preview-canvas'),
            ctx: document.getElementById('preview-canvas').getContext('2d'),
            presets: {
                saveBtn: document.getElementById('preset-save-btn'),
                select: document.getElementById('preset-select'),
                loadBtn: document.getElementById('preset-load-btn'),
                deleteBtn: document.getElementById('preset-delete-btn'),
            }
        };

        // --- CORE LOGIC ---
        function collectConfig() {
            const config = {
                shapes: [],
                cellControls: []
            };
            for (const key in dom.inputs) {
                const el = dom.inputs[key];
                const type = el.type;
                if (type === 'checkbox') {
                    config[key] = el.checked;
                } else if (type === 'textarea' || type === 'text') {
                    config[key] = el.value;
                } else {
                    config[key] = parseFloat(el.value);
                }
            }

            const shapeLiElements = dom.shapeOrderList.querySelectorAll('li');
            shapeLiElements.forEach(li => {
                const shapeName = li.getAttribute('data-shape');
                config.shapes.push({
                    name: shapeName,
                    enabled: li.querySelector('input[type="checkbox"]').checked,
                    color: { spiral: '#0d6efd', circle: '#dc3545', square: '#198754' }[shapeName],
                });
            });

            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            cellGroups.forEach(group => {
                config.cellControls.push({
                    x: parseFloat(group.querySelector('.cell-center-x').value),
                    y: parseFloat(group.querySelector('.cell-center-y').value),
                    diameter: parseFloat(group.querySelector('.cell-diameter').value),
                    enabled: group.querySelector('.cell-enabled').checked,
                    speeds: {
                        spiral: parseFloat(group.querySelector('.cell-spiral-speed').value),
                        circle: parseFloat(group.querySelector('.cell-circle-speed').value),
                        square: parseFloat(group.querySelector('.cell-square-speed').value)
                    }
                });
            });
            return config;
        }

        function applyConfig(config) {
            for (const key in dom.inputs) {
                 const el = dom.inputs[key];
                 if (!el || config[key] === undefined) continue;

                 if (el.type === 'checkbox') {
                     el.checked = config[key];
                 } else { // covers textarea, text, number
                     el.value = config[key];
                 }
            }

            updateCellCenterInputs();

            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            cellGroups.forEach((group, index) => {
                const cellConfig = config.cellControls[index];
                if (cellConfig) {
                    group.querySelector('.cell-center-x').value = cellConfig.x;
                    group.querySelector('.cell-center-y').value = cellConfig.y;
                    group.querySelector('.cell-diameter').value = cellConfig.diameter;
                    group.querySelector('.cell-enabled').checked = cellConfig.enabled;
                    group.querySelector('.cell-spiral-speed').value = cellConfig.speeds.spiral;
                    group.querySelector('.cell-circle-speed').value = cellConfig.speeds.circle;
                    group.querySelector('.cell-square-speed').value = cellConfig.speeds.square;
                }
            });

            const shapeLiElements = dom.shapeOrderList.querySelectorAll('li');
            shapeLiElements.forEach(li => {
                const shapeName = li.getAttribute('data-shape');
                const shapeConfig = config.shapes.find(s => s.name === shapeName);
                if (shapeConfig) {
                    li.querySelector('input[type="checkbox"]').checked = shapeConfig.enabled;
                }
            });

            generate();
        }

        function generate() {
            const config = collectConfig();
            const presetName = dom.inputs.presetName.value.trim();

            const augmentedData = config.cellControls.map(cell => {
                if (!cell.enabled) return null;
                const targetRadius = cell.diameter / 2;
                const center = { x: cell.x, y: cell.y };
                const spiralPoints = generateSpiralPoints(config, center, targetRadius);
                return {
                    center,
                    spiralPoints,
                    targetRadius,
                    squareVertices: calculateSquareVertices(targetRadius, center)
                };
            }).filter(Boolean);

            const analysis = calculateDistances(config, augmentedData);
            renderAnalysisTable(analysis);
            updateOverlapAnalysis();

            updateDiameterDisplays(augmentedData);
            const gcodeFiles = generateGCodeFiles(config, augmentedData, presetName);
            renderGCodeOutputs(gcodeFiles);
            drawPreview(config, augmentedData);
        }

        // --- DISTANCE & TIME CALCULATION LOGIC ---
        function calculateDistances(config, augmentedData) {
            const analysis = {
                square: { distance_mm: 0, time_s: 0 },
                circle: { distance_mm: 0, time_s: 0 },
                spiral: { distance_mm: 0, time_s: 0 },
            };

            const enabledShapes = config.shapes.filter(s => s.enabled).map(s => s.name);

            let dataIndex = 0;
            config.cellControls.forEach((cell) => {
                if (!cell.enabled) return;
                const data = augmentedData[dataIndex++];
                if (!data) return;

                if (enabledShapes.includes('square')) {
                    const dist = 8 * data.targetRadius;
                    const speed = cell.speeds.square;
                    analysis.square.distance_mm += dist;
                    if (speed > 0) analysis.square.time_s += dist / speed;
                }
                if (enabledShapes.includes('circle')) {
                    const dist = 2 * Math.PI * data.targetRadius;
                    const speed = cell.speeds.circle;
                    analysis.circle.distance_mm += dist;
                    if (speed > 0) analysis.circle.time_s += dist / speed;
                }
                if (enabledShapes.includes('spiral')) {
                    const points = data.spiralPoints;
                    let spiralLength = 0;
                    for (let i = 1; i < points.x.length; i++) {
                        const dx = points.x[i] - points.x[i-1];
                        const dy = points.y[i] - points.y[i-1];
                        spiralLength += Math.sqrt(dx*dx + dy*dy);
                    }
                    const speed = cell.speeds.spiral;
                    analysis.spiral.distance_mm += spiralLength;
                    if (speed > 0) analysis.spiral.time_s += spiralLength / speed;
                }
            });

            // Multiply by number of passes
            const numPasses = config.numPasses > 0 ? config.numPasses : 1;
            analysis.square.distance_mm *= numPasses;
            analysis.square.time_s *= numPasses;
            analysis.circle.distance_mm *= numPasses;
            analysis.circle.time_s *= numPasses;
            analysis.spiral.distance_mm *= numPasses;
            analysis.spiral.time_s *= numPasses;

            // Calculate total after passes
            analysis.total = {
                distance_mm: analysis.square.distance_mm + analysis.circle.distance_mm + analysis.spiral.distance_mm,
                time_s: analysis.square.time_s + analysis.circle.time_s + analysis.spiral.time_s
            };

            return analysis;
        }

        // --- ANALYSIS TABLE RENDERER ---
        function renderAnalysisTable(analysis) {
            if (!dom.distanceSummary) return;

            const f2 = (n) => n.toFixed(2);

            dom.distanceSummary.innerHTML = `
                <table id="distance-table">
                    <thead>
                        <tr>
                            <th>Shape</th>
                            <th>Dist (mm)</th>
                            <th>Dist (cm)</th>
                            <th>Time (s)</th>
                            <th>Time (min)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>üî≤ Square</td>
                            <td>${f2(analysis.square.distance_mm)}</td>
                            <td>${f2(analysis.square.distance_mm / 10)}</td>
                            <td>${f2(analysis.square.time_s)}</td>
                            <td>${f2(analysis.square.time_s / 60)}</td>
                        </tr>
                        <tr>
                            <td>‚≠ï Circle</td>
                            <td>${f2(analysis.circle.distance_mm)}</td>
                            <td>${f2(analysis.circle.distance_mm / 10)}</td>
                            <td>${f2(analysis.circle.time_s)}</td>
                            <td>${f2(analysis.circle.time_s / 60)}</td>
                        </tr>
                        <tr>
                            <td>üåÄ Spiral</td>
                            <td>${f2(analysis.spiral.distance_mm)}</td>
                            <td>${f2(analysis.spiral.distance_mm / 10)}</td>
                            <td>${f2(analysis.spiral.time_s)}</td>
                            <td>${f2(analysis.spiral.time_s / 60)}</td>
                        </tr>
                    </tbody>
                    <tfoot>
                        <tr>
                            <td>Total</td>
                            <td>${f2(analysis.total.distance_mm)}</td>
                            <td>${f2(analysis.total.distance_mm / 10)}</td>
                            <td>${f2(analysis.total.time_s)}</td>
                            <td>${f2(analysis.total.time_s / 60)}</td>
                        </tr>
                    </tfoot>
                </table>
                <div class="assumptions">
                    <h4>Calculation Assumptions:</h4>
                    <ul>
                        <li><strong>Constant Speed:</strong> Time is calculated using the formula $ \\text{Time} = \\text{Distance} / \\text{Speed} $. It assumes the machine instantly reaches the set speed for each segment.</li>
                        <li><strong>Negligible Acceleration:</strong> The time taken for acceleration and deceleration at path starts, ends, and corners is not included.</li>
                        <li><strong>Drawing Time Only:</strong> The analysis only includes time for drawing movements (laser on). It does not account for rapid travel time between drawing areas or the specified servo delays.</li>
                    </ul>
                </div>
            `;
        }

        // --- OVERLAP ANALYSIS ---
        function updateOverlapAnalysis() {
            const beamWidth = parseFloat(dom.inputs.laserWidth.value);
            const currentTightness = parseFloat(dom.inputs.spiralTightness.value);

            if (isNaN(beamWidth) || beamWidth <= 0) {
                dom.overlapAnalysisResult.innerHTML = `<p>Please enter a valid, positive beam width.</p>`;
                dom.overlapAnalysisResult.className = 'result-display';
                return;
            }

            const minTightness = beamWidth / (2 * Math.PI);

            let messageHTML = `<p>To avoid overlap, 'Spiral Tightness' must be at least <strong>${minTightness.toFixed(4)} mm/rad</strong>.</p>`;

            if (currentTightness >= minTightness) {
                dom.overlapAnalysisResult.className = 'result-display safe';
                messageHTML += `<p>‚úÖ Your current setting of ${currentTightness} mm/rad is sufficient.</p>`;
            } else {
                dom.overlapAnalysisResult.className = 'result-display warning';
                messageHTML += `<p>‚ö†Ô∏è Your current setting of ${currentTightness} mm/rad is too low and may cause overlap.</p>`;
            }
            dom.overlapAnalysisResult.innerHTML = messageHTML;
        }


        // --- G-CODE GENERATION ---
        function generateGCodeFiles(config, augmentedData, presetName) {
            const files = [];
            const f4 = (n) => n.toFixed(4);
            const baseFilename = presetName ? presetName.replace(/[\s/\\?%*:|"<>]/g, '_') : 'unnamed_preset';
            const numPasses = config.numPasses > 0 ? config.numPasses : 1;

            config.shapes.forEach(shapeInfo => {
                if (!shapeInfo.enabled) return;

                let gcode = ``;
                const travelSpeedMin = config.travelSpeed * 60;
                const servoDelay = `G4 P${config.servoDelay} ; Wait before/after servo move\n`;

                const startScript = (config.startGcode || '')
                    .replace(/{Z_HEIGHT}/g, f4(config.zHeight))
                    .replace(/{TRAVEL_FEEDRATE}/g, travelSpeedMin.toFixed(0));

                const endScript = (config.endGcode || '')
                    .replace(/{TRAVEL_FEEDRATE}/g, travelSpeedMin.toFixed(0));

                gcode += `; G-code for ${shapeInfo.name.toUpperCase()}S\n`;
                gcode += `; Generated on ${new Date().toLocaleString()}\n`;
                gcode += `; ========================================\n`;
                gcode += startScript + '\n';

                // --- Build G-code for a single pass ---
                let singlePassGcode = '';
                let dataIndex = 0;
                config.cellControls.forEach((cell, index) => {
                    if (!cell.enabled) return;
                    const data = augmentedData[dataIndex++];
                    if (!data) return;

                    const speedMms = cell.speeds[shapeInfo.name];
                    const speedMmm = speedMms * 60;
                    singlePassGcode += `\n; --- Cell ${index + 1} (${cell.x}, ${cell.y}) ${shapeInfo.name} ---\n`;

                    switch (shapeInfo.name) {
                        case 'square': {
                            const v = data.squareVertices;
                            singlePassGcode += `G0 X${f4(v.bl.x)} Y${f4(v.bl.y)} F${travelSpeedMin}\n`;
                            singlePassGcode += servoDelay + `${LASER_OPEN}\n` + servoDelay;
                            singlePassGcode += `G1 X${f4(v.br.x)} Y${f4(v.br.y)} F${speedMmm}\n`;
                            singlePassGcode += `G1 X${f4(v.tr.x)} Y${f4(v.tr.y)} F${speedMmm}\n`;
                            singlePassGcode += `G1 X${f4(v.tl.x)} Y${f4(v.tl.y)} F${speedMmm}\n`;
                            singlePassGcode += `G1 X${f4(v.bl.x)} Y${f4(v.bl.y)} F${speedMmm}\n`;
                            singlePassGcode += servoDelay + `${LASER_CLOSE}\n` + servoDelay;
                            break;
                        }
                        case 'circle': {
                            const startX = data.center.x + data.targetRadius;
                            const startY = data.center.y;
                            singlePassGcode += `G0 X${f4(startX)} Y${f4(startY)} F${travelSpeedMin}\n`;
                            singlePassGcode += servoDelay + `${LASER_OPEN}\n` + servoDelay;
                            singlePassGcode += `G2 X${f4(startX)} Y${f4(startY)} I${f4(-data.targetRadius)} J0 F${speedMmm}\n`;
                            singlePassGcode += servoDelay + `${LASER_CLOSE}\n` + servoDelay;
                            break;
                        }
                        case 'spiral': {
                            const points = data.spiralPoints;
                            if (points.x.length < 2) break;
                            singlePassGcode += `G0 X${f4(points.x[0])} Y${f4(points.y[0])} F${travelSpeedMin}\n`;
                            singlePassGcode += servoDelay + `${LASER_OPEN}\n` + servoDelay;
                            singlePassGcode += `G1 X${f4(points.x[1])} Y${f4(points.y[1])} F${speedMmm}\n`;
                            for (let i = 2; i < points.x.length; i++) {
                                const startPointAbs = { x: points.x[i - 1], y: points.y[i - 1] };
                                const endPointAbs = { x: points.x[i], y: points.y[i] };
                                const iOffset = data.center.x - startPointAbs.x;
                                const jOffset = data.center.y - startPointAbs.y;
                                singlePassGcode += `G3 X${f4(endPointAbs.x)} Y${f4(endPointAbs.y)} I${f4(iOffset)} J${f4(jOffset)} F${speedMmm}\n`;
                            }
                            singlePassGcode += servoDelay + `${LASER_CLOSE}\n` + servoDelay;
                            break;
                        }
                    }
                });

                // --- Repeat the single pass G-code block ---
                for (let i = 0; i < numPasses; i++) {
                    gcode += `\n; --- PASS ${i + 1} of ${numPasses} ---\n`;
                    gcode += singlePassGcode;
                }

                gcode += `\n; --- End of Job ---\n`;
                gcode += endScript + '\n';

                files.push({
                    title: `File for ${shapeInfo.name.charAt(0).toUpperCase() + shapeInfo.name.slice(1)}s`,
                    filename: `${baseFilename}_${shapeInfo.name}s.gcode`,
                    code: gcode
                });
            });

            return files;
        }

        // --- POINT CALCULATION HELPERS ---
        function generateSpiralPoints(p, center, targetRadius) {
            const xPoints = [], yPoints = [];
            const totalAngle = p.numRotations * 2 * Math.PI;
            xPoints.push(center.x); yPoints.push(center.y);

            let theta = 0.001;
            while (theta < totalAngle) {
                const rSpiral = p.spiralTightness * theta;
                if (rSpiral > targetRadius) break;

                const xShifted = (rSpiral * Math.cos(theta)) + center.x;
                const yShifted = (rSpiral * Math.sin(theta)) + center.y;
                xPoints.push(xShifted); yPoints.push(yShifted);

                const dTheta = p.stepLength / (p.spiralTightness * Math.sqrt(1 + theta ** 2));
                theta += dTheta;
            }
            return { x: xPoints, y: yPoints };
        }

        function calculateSquareVertices(radius, center) {
            return {
                bl: { x: center.x - radius, y: center.y - radius },
                br: { x: center.x + radius, y: center.y - radius },
                tr: { x: center.x + radius, y: center.y + radius },
                tl: { x: center.x - radius, y: center.y + radius },
            };
        }

        // --- CANVAS PREVIEW ---
        function drawGrid(config) {
            const { ctx, canvas } = dom;
            const scale = canvas.width / config.gridSize;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            const originalFillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillStyle = originalFillStyle;
            ctx.lineWidth = 1;
            ctx.font = '12px sans-serif';

            for (let i = 50; i <= 350; i += 50) {
                const x = i * scale;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(i, x + 5, 5);

                const y = canvas.height - (i * scale);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                ctx.fillText(i, 5, y + 5);
            }

            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.arc(0, canvas.height, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = originalFillStyle;
        }

        function drawPreview(config, augmentedData) {
            const { ctx, canvas } = dom;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth > 0) {
                const canvasRatio = canvas.width / canvas.height;
                const imgRatio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
                let newWidth, newHeight;

                if (imgRatio > canvasRatio) {
                    newWidth = canvas.width;
                    newHeight = canvas.width / imgRatio;
                } else {
                    newHeight = canvas.height;
                    newWidth = canvas.height * imgRatio;
                }

                newWidth *= PREVIEW_IMAGE_SCALE;
                newHeight *= PREVIEW_IMAGE_SCALE;

                const drawX = (canvas.width - newWidth) / 2 + PREVIEW_IMAGE_OFFSET_X;
                const drawY = (canvas.height - newHeight) / 2 + PREVIEW_IMAGE_OFFSET_Y;

                ctx.drawImage(backgroundImage, drawX, drawY, newWidth, newHeight);
            }

            if (config.showGrid) {
                drawGrid(config);
            }

            const scale = canvas.width / config.gridSize;
            const transform = (x, y) => ({ x: x * scale, y: canvas.height - (y * scale) });

            let dataIndex = 0;
            config.cellControls.forEach((cell) => {
                if (!cell.enabled) return;

                const data = augmentedData[dataIndex++];
                if (!data) return;

                config.shapes.forEach(shape => {
                    if (!shape.enabled) return;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = shape.color;
                    ctx.beginPath();

                    switch (shape.name) {
                        case 'spiral':
                            const points = data.spiralPoints;
                            if (points.x.length > 1) {
                                let start = transform(points.x[0], points.y[0]);
                                ctx.moveTo(start.x, start.y);
                                for (let i = 1; i < points.x.length; i++) {
                                    let point = transform(points.x[i], points.y[i]);
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                            break;
                        case 'circle':
                            const canvasCenter = transform(data.center.x, data.center.y);
                            ctx.arc(canvasCenter.x, canvasCenter.y, data.targetRadius * scale, 0, 2 * Math.PI);
                            break;
                        case 'square':
                            const v = data.squareVertices;
                            let bl = transform(v.bl.x, v.bl.y); let br = transform(v.br.x, v.br.y);
                            let tr = transform(v.tr.x, v.tr.y); let tl = transform(v.tl.x, v.tl.y);
                            ctx.moveTo(bl.x, bl.y); ctx.lineTo(br.x, br.y);
                            ctx.lineTo(tr.x, tr.y); ctx.lineTo(tl.x, tl.y);
                            ctx.closePath();
                            break;
                    }
                    ctx.stroke();
                });
            });
        }

        // --- DYNAMIC UI MANAGEMENT ---
        function renderGCodeOutputs(files) {
            dom.gcodeOutputsContainer.innerHTML = '';
            if (files.length === 0) {
                 dom.gcodeOutputsContainer.innerHTML = '<div class="output-group"><p>No G-code files to generate. Enable a shape type and click "Apply" to begin.</p></div>';
                 return;
            }
            files.forEach((file) => {
                const outputGroup = document.createElement('div');
                outputGroup.className = 'output-group';

                const title = document.createElement('h2');
                title.textContent = file.title;

                const textarea = document.createElement('textarea');
                textarea.className = 'gcode-output-area';
                textarea.readOnly = true;
                textarea.value = file.code;

                const btnGroup = document.createElement('div');
                btnGroup.className = 'btn-group';

                const copyButton = document.createElement('button');
                copyButton.className = 'btn copy-btn';
                copyButton.textContent = 'üìã Copy';
                copyButton.onclick = () => {
                    textarea.select();
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        copyButton.textContent = '‚úÖ Copied!';
                        setTimeout(() => { copyButton.textContent = 'üìã Copy'; }, 2000);
                    });
                };

                const downloadButton = document.createElement('button');
                downloadButton.className = 'btn download-btn';
                downloadButton.textContent = 'üíæ Download .gcode';
                downloadButton.onclick = () => {
                    const blob = new Blob([file.code], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = file.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                btnGroup.appendChild(copyButton);
                btnGroup.appendChild(downloadButton);
                outputGroup.appendChild(title);
                outputGroup.appendChild(textarea);
                outputGroup.appendChild(btnGroup);
                dom.gcodeOutputsContainer.appendChild(outputGroup);
            });
        }

        function updateDiameterDisplays(augmentedData) {
            const cellGroups = dom.cellCentersContainer.querySelectorAll('.cell-control-group');
            let dataIndex = 0;
            cellGroups.forEach((group) => {
                 const display = group.querySelector('.diameter-display');
                 const isEnabled = group.querySelector('.cell-enabled').checked;

                 if (display && isEnabled) {
                    const data = augmentedData[dataIndex++];
                    if (data && data.spiralPoints.x.length > 1) {
                         const lastX = data.spiralPoints.x.slice(-1)[0];
                         const lastY = data.spiralPoints.y.slice(-1)[0];
                         const finalRadius = Math.sqrt((lastX - data.center.x)**2 + (lastY - data.center.y)**2);
                         display.textContent = `Final Diameter: ${(finalRadius * 2).toFixed(2)} mm`;
                    } else if (data) {
                         display.textContent = `Final Diameter: 0.00 mm`;
                    }
                 } else if (display) {
                    display.textContent = 'Final Diameter: 0.00 mm';
                 }
            });
        }

        function updateCellCenterInputs() {
            const rows = parseInt(dom.inputs.gridRows.value) || 1;
            const cols = parseInt(dom.inputs.gridCols.value) || 1;
            const gridSize = parseFloat(dom.inputs.gridSize.value);

            dom.cellCentersContainer.innerHTML = '';

            const cellWidth = gridSize / cols;
            const cellHeight = gridSize / rows;

            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    const defaultCenterX = (c - 0.5) * cellWidth;
                    const defaultCenterY = (r - 0.5) * cellHeight;

                    const group = document.createElement('div');
                    group.className = 'cell-control-group';
                    group.innerHTML = `
                        <label class="cell-label">
                            <b>Cell (${r}, ${c})</b>
                            <input type="checkbox" class="cell-enabled" title="Enable/Disable this cell" checked>
                        </label>
                        <div class="coord-group">
                           <input type="number" class="cell-center-x" value="${defaultCenterX.toFixed(2)}" title="Center X (mm)">
                           <input type="number" class="cell-center-y" value="${defaultCenterY.toFixed(2)}" title="Center Y (mm)">
                        </div>
                        <div class="coord-group">
                           <label class="cell-diameter-label">Diameter:</label>
                           <input type="number" class="cell-diameter" value="50" title="Target Diameter (mm)">
                        </div>
                        <div class="cell-speed-group">
                            <label>üåÄ Speed (mm/s):</label>
                            <input type="number" class="cell-spiral-speed" value="80">
                            <label>‚≠ï Speed (mm/s):</label>
                            <input type="number" class="cell-circle-speed" value="100">
                            <label>üî≤ Speed (mm/s):</label>
                            <input type="number" class="cell-square-speed" value="70">
                        </div>
                        <div class="diameter-display">Final Diameter: 0.00 mm</div>
                    `;
                    dom.cellCentersContainer.appendChild(group);
                }
            }
        }

        // --- PRESET MANAGEMENT ---
        const PRESET_STORAGE_KEY = 'gcodeGeneratorPresets';

        function getPresets() {
            return JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
        }

        function savePresets(presets) {
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
        }

        function updatePresetList() {
            const presets = getPresets();
            const select = dom.presets.select;
            select.innerHTML = '';
            for (const name in presets) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            }
        }

        // --- EVENT LISTENERS ---
        dom.applyBtn.addEventListener('click', generate);

        dom.inputs.gridRows.addEventListener('input', updateCellCenterInputs);
        dom.inputs.gridCols.addEventListener('input', updateCellCenterInputs);
        dom.inputs.gridSize.addEventListener('input', updateCellCenterInputs);

        dom.inputs.laserWidth.addEventListener('input', updateOverlapAnalysis);
        dom.inputs.spiralTightness.addEventListener('input', updateOverlapAnalysis);

        dom.presets.saveBtn.addEventListener('click', () => {
            const name = dom.inputs.presetName.value.trim();
            if (!name) {
                alert('Please enter a name for the preset.');
                return;
            }
            const presets = getPresets();
            presets[name] = collectConfig();
            savePresets(presets);
            updatePresetList();
            alert(`Preset "${name}" saved!`);
        });

        dom.presets.loadBtn.addEventListener('click', () => {
            const name = dom.presets.select.value;
            if (!name) {
                alert('No preset selected.');
                return;
            }
            const presets = getPresets();
            const config = presets[name];
            if (config) {
                applyConfig(config);
                alert(`Preset "${name}" loaded!`);
            }
        });

        dom.presets.deleteBtn.addEventListener('click', () => {
            const name = dom.presets.select.value;
            if (!name) {
                alert('No preset selected.');
                return;
            }
            if (confirm(`Are you sure you want to delete the preset "${name}"?`)) {
                const presets = getPresets();
                delete presets[name];
                savePresets(presets);
                updatePresetList();
                alert(`Preset "${name}" deleted.`);
            }
        });

        dom.shapeOrderList.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(dom.shapeOrderList, e.clientY);
            const dragging = document.querySelector('.dragging');
            if (afterElement == null) dom.shapeOrderList.appendChild(dragging);
            else dom.shapeOrderList.insertBefore(dragging, afterElement);
        });
        dom.shapeOrderList.querySelectorAll('li').forEach(item => {
            item.addEventListener('dragstart', () => setTimeout(() => item.classList.add('dragging'), 0));
            item.addEventListener('dragend', () => item.classList.remove('dragging'));
        });
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            dom.inputs.startGcode.value = `G90\nM140 S0\nM104 S0\nG28\nG0 Z{Z_HEIGHT} F{TRAVEL_FEEDRATE}`;
            dom.inputs.endGcode.value = `G90\nG0 Z350 F{TRAVEL_FEEDRATE}`;

            backgroundImage.src = 'REALgridfinitydesign.JPG';
            backgroundImage.onload = () => generate();
            backgroundImage.onerror = () => {
                console.error("Could not load 'REALgridfinitydesign.JPG'. Make sure it is in the same folder as the HTML file.");
                generate();
            };

            updateCellCenterInputs();
            updatePresetList();
            generate();
        });
    </script>
</body>
</html>
